clear all
close all
clc
% {name] alternatif : convert vector x from [ x, vx, y, vy ,z, vz] to [x,
% y,z, vx, vy, vz]

%pkg load statistics
%pkg load geom3d

% Parameters of the cameras set up
% f =
% b =
% fps = 24

M = 10; % Number of Gaussians that we use
T_e = 1/24;
T = 24; %Number of observations
sigma_Q = 100;
sigma_px = sigma_Q*50;
sigma_py = sigma_Q*50;
sigma_pz = sigma_Q*50;

F = [ 1 T_e 0 0 0 0;
    0 1   0 0 0 0;
    0 0   1 T_e 0 0;
    0 0   0 1 0 0;
    0 0 0 0 1 T_e;
    0 0 0 0 0 1];

% F alternatif
% F = [ 1 0 0 T_e 0 0;
%     0 1 0 0 T_e 0;
%     0 0 1 0 0 T_e;
%     0 0 0 1 0 0;
%     0 0 0 0 1 0;
%     0 0 0 0 0 1];

H = [ 1 0 0 0 0 0;
   0 0 1 0 0 0;
   0 0 0 0 1 0];

% H alternatif
% H = [ 1 0 0 0 0 0;
%    0 0 1 0 0 0;
%    0 0 0 0 1 0];

MQ = [ (T_e^3)/3   (T_e^2)/2 0         0          0     0           ; 
      (T_e^2)/2   T_e       0         0           0     0           ;  
      0           0         (T_e^3)/3 (T_e^2)/2   0     0      ;
      0           0         (T_e^2)/2 T_e         0     0      ;
      0           0          0    0        (T_e^3)/3 (T_e^2)/2;
      0           0          0    0         (T_e^2)/2 T_e     ];
  
 
%  MQ alternatif 
%  MQ = [ (T_e^3)/3    0         0     (T_e^2)/2     0          0            ; 
%       0           (T_e^3)/3    0         0     (T_e^2)/2      0            ; 
%       0              0      (T_e^3)/3    0         0         (T_e^2)/2     ; 
%    (T_e^2)/2         0         0         T_e       0          0            ;
%       0          (T_e^2)/2     0         0        T_e         0            ;
%       0              0      (T_e^2)/2    0         0         T_e         ] ;

Q = (sigma_Q^2) * MQ;

R = [ sigma_px^2 0          0;
     0           sigma_py^2 0;
     0           0          sigma_pz^2]; 

% We have to determine which unite are used for postions and speed (m, m/s
% ? cm, cm/s ? 
x_init = [3 40 -4 20 2 30]';

% x_init alternatif 
% x_init = [3 -4 2 40 20 30] ;


variance_initial = 20000;

% Not useful since we considere the modèle calibrated and the only useful
% informations are f and b (parameters from the hardware and its relative
% position)

distance_entre_camera = 10;
position_camera_1 = [0,0,0];
position_camera_2 = [distance_entre_camera,0,0];

vecteur_x = creat_trajectoire_3D(F, Q, x_init, T);
%TODO change vecteur_y, because is should notbe that, we have to pass by the camera.
vecteur_y = creat_observations_3D(H,R,vecteur_x,T);


[x_kalm_mean,x_kalm] = Kalman_New_Dimension(M,H,T,F,MQ,Q,R,x_init,vecteur_y,variance_initial);


[eq , eqm] = mean_erreur_quadratique_suj(vecteur_x, x_kalm_mean, T );
% The eqm is very high it should be a vecteur computing the error for each
% component of the vector or at least an eqm for the position vector and
% one for the speed vector
eqm

%eqm

% Trajectoires 
figure(4)
plot3(vecteur_x(1,:), vecteur_x(3,:), vecteur_x(5,:),'b')
hold on
plot3(vecteur_y(1,:), vecteur_y(2,:), vecteur_y(3,:),'g')
hold on
plot3(x_kalm_mean(1,:), x_kalm_mean(3,:),x_kalm_mean(5,:),'*')
hold on
for i=1:M
  plot3(reshape (x_kalm(1,i,:), T, 1), reshape (x_kalm(3,i,:), T, 1),reshape (x_kalm(5,i,:), T, 1),'r')
end